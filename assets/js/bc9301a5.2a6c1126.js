"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1061],{3099:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api/api-reference","title":"API Reference","description":"Project Mapper can be used programmatically in your Node.js applications. This reference covers the available functions and their parameters.","source":"@site/docs/api/api-reference.md","sourceDirName":"api","slug":"/api/api-reference","permalink":"/ai-project-mapper/docs/api/api-reference","draft":false,"unlisted":false,"editUrl":"https://github.com/mrlynn/ai-project-mapper/tree/main/docs/docs/api/api-reference.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"LLM Workflow Guide","permalink":"/ai-project-mapper/docs/guides/llm-workflow"},"next":{"title":"Architecture Overview","permalink":"/ai-project-mapper/docs/concepts/architecture"}}');var s=i(4848),r=i(8453);const o={sidebar_position:1},a="API Reference",c={},l=[{value:"Main Functions",id:"main-functions",level:2},{value:"generateProjectMap(inputDir, options)",id:"generateprojectmapinputdir-options",level:3},{value:"analyzeProject(inputDir, options)",id:"analyzeprojectinputdir-options",level:3},{value:"generateKnowledgeTransfer(analysis, options)",id:"generateknowledgetransferanalysis-options",level:3},{value:"analyzeProjectSemantics(projectDir, options)",id:"analyzeprojectsemanticsprojectdir-options",level:3},{value:"enhancedKnowledgeTransfer(analysis, options)",id:"enhancedknowledgetransferanalysis-options",level:3},{value:"generateContextQuestionnaire(analysis)",id:"generatecontextquestionnaireanalysis",level:3},{value:"Visualization Functions",id:"visualization-functions",level:2},{value:"generateConceptNetworkVisualization(semantics, options)",id:"generateconceptnetworkvisualizationsemantics-options",level:3},{value:"generateMermaidConceptDiagram(semantics, options)",id:"generatemermaidconceptdiagramsemantics-options",level:3},{value:"exportInteractiveConceptNetwork(semantics, outputPath)",id:"exportinteractiveconceptnetworksemantics-outputpath",level:3},{value:"generateConceptDistributionHeatmap(semantics, options)",id:"generateconceptdistributionheatmapsemantics-options",level:3},{value:"Type Definitions",id:"type-definitions",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"api-reference",children:"API Reference"})}),"\n",(0,s.jsx)(n.p,{children:"Project Mapper can be used programmatically in your Node.js applications. This reference covers the available functions and their parameters."}),"\n",(0,s.jsx)(n.h2,{id:"main-functions",children:"Main Functions"}),"\n",(0,s.jsx)(n.h3,{id:"generateprojectmapinputdir-options",children:"generateProjectMap(inputDir, options)"}),"\n",(0,s.jsx)(n.p,{children:"Analyzes a project directory and generates a knowledge transfer document."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inputDir"})," (string): Path to the project directory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options"})," (object): Configuration options","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"template"})," (string): Template to use ('standard', 'minimal', 'detailed')"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"format"})," (string): Output format ('markdown', 'json')"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"includeGuide"})," (boolean): Whether to include the LLM guide"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ignore"})," (string[]): Glob patterns to ignore"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"depth"})," (number): Maximum directory depth to analyze"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Promise<object>"}),": Object containing ",(0,s.jsx)(n.code,{children:"analysis"})," and ",(0,s.jsx)(n.code,{children:"knowledgeTransfer"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { generateProjectMap } from 'project-mapper';\n\nasync function analyzeMyProject() {\n  const result = await generateProjectMap('./my-project', {\n    template: 'detailed',\n    includeGuide: true\n  });\n  \n  console.log(result.knowledgeTransfer);\n  \n  // Access raw analysis data\n  const rawAnalysis = result.analysis;\n  \n  // Do something with the data\n  const componentCount = rawAnalysis.overview.totalFiles;\n  console.log(`Project has ${componentCount} files`);\n}\n\nanalyzeMyProject();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"analyzeprojectinputdir-options",children:"analyzeProject(inputDir, options)"}),"\n",(0,s.jsx)(n.p,{children:"Analyzes a project directory without generating a knowledge transfer document."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inputDir"})," (string): Path to the project directory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options"})," (object): Configuration options","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ignorePaths"})," (string[]): Glob patterns to ignore"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxDepth"})," (number): Maximum directory depth to analyze"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"verbose"})," (boolean): Enable verbose output"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Promise<object>"}),": Detailed analysis of the project"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { analyzeProject } from 'project-mapper';\n\nasync function getProjectAnalysis() {\n  const analysis = await analyzeProject('./my-project', {\n    ignorePaths: ['node_modules/**', 'dist/**'],\n    maxDepth: 5\n  });\n  \n  console.log(`Found ${analysis.overview.totalFiles} files`);\n  console.log(`Found ${analysis.overview.totalDirectories} directories`);\n  \n  // Access important files\n  for (const file of analysis.structure.importantFiles) {\n    console.log(`Important file: ${file.path} (score: ${file.score})`);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"generateknowledgetransferanalysis-options",children:"generateKnowledgeTransfer(analysis, options)"}),"\n",(0,s.jsx)(n.p,{children:"Generates a knowledge transfer document from an existing analysis."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"analysis"})," (object): Project analysis object"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options"})," (object): Configuration options","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"projectName"})," (string): Name to use for the project"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"template"})," (string): Template to use ('standard', 'minimal', 'detailed')"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"format"})," (string): Output format ('markdown', 'json')"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"includeGuide"})," (boolean): Whether to include the LLM guide"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Promise<string|object>"}),": Knowledge transfer document in the specified format"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { analyzeProject, generateKnowledgeTransfer } from 'project-mapper';\n\nasync function generateCustomDocument() {\n  // First analyze the project\n  const analysis = await analyzeProject('./my-project');\n  \n  // Then generate a knowledge transfer document\n  const document = await generateKnowledgeTransfer(analysis, {\n    projectName: 'My Amazing Project',\n    template: 'minimal',\n    format: 'markdown'\n  });\n  \n  console.log(document);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"analyzeprojectsemanticsprojectdir-options",children:"analyzeProjectSemantics(projectDir, options)"}),"\n",(0,s.jsx)(n.p,{children:"Performs semantic analysis on a project directory to extract domain concepts and terminology."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"projectDir"})," (string): Path to the project directory"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options"})," (object): Configuration options","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ignorePaths"})," (string[]): Glob patterns to ignore"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"includeComments"})," (boolean): Include code comments in analysis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"includeDocs"})," (boolean): Include documentation files in analysis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"includeIdentifiers"})," (boolean): Include code identifiers in analysis"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"minTermFrequency"})," (number): Minimum frequency for a term to be included"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"maxTerms"})," (number): Maximum number of terms to include"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Promise<object>"}),": Semantic analysis results"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { analyzeProjectSemantics } from 'project-mapper';\n\nasync function getSemanticAnalysis() {\n  const semantics = await analyzeProjectSemantics('./my-project', {\n    minTermFrequency: 2,\n    maxTerms: 50\n  });\n  \n  console.log('Domain concepts:');\n  for (const concept of semantics.domainConcepts) {\n    console.log(`- ${concept.name} (frequency: ${concept.frequency})`);\n  }\n  \n  console.log('Domain glossary:');\n  for (const entry of semantics.domainGlossary) {\n    console.log(`- ${entry.term}: ${entry.definition}`);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"enhancedknowledgetransferanalysis-options",children:"enhancedKnowledgeTransfer(analysis, options)"}),"\n",(0,s.jsx)(n.p,{children:"Generates an enhanced knowledge transfer document that includes semantic information."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"analysis"})," (object): Project analysis object, optionally including semantics data"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"options"})," (object): Configuration options (same as generateKnowledgeTransfer)","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"projectDir"})," (string): Path to project directory (needed if semantics not included)"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Promise<string|object>"}),": Enhanced knowledge transfer document"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { analyzeProject, analyzeProjectSemantics, enhancedKnowledgeTransfer } from 'project-mapper';\n\nasync function generateEnhancedDocument() {\n  // Analyze the project\n  const analysis = await analyzeProject('./my-project');\n  \n  // Add semantic analysis\n  analysis.semantics = await analyzeProjectSemantics('./my-project');\n  \n  // Generate enhanced document\n  const document = await enhancedKnowledgeTransfer(analysis, {\n    projectName: 'My Project',\n    template: 'standard'\n  });\n  \n  console.log(document);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"generatecontextquestionnaireanalysis",children:"generateContextQuestionnaire(analysis)"}),"\n",(0,s.jsx)(n.p,{children:"Generates a context questionnaire based on project analysis to gather additional information."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"analysis"})," (object): Project analysis object with semantics data"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Returns:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"object: Questionnaire object with title, description, and questions"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"import { analyzeProject, analyzeProjectSemantics, generateContextQuestionnaire } from 'project-mapper';\nimport fs from 'fs';\n\nasync function createQuestionnaire() {\n  // Analyze the project\n  const analysis = await analyzeProject('./my-project');\n  \n  // Add semantic analysis\n  analysis.semantics = await analyzeProjectSemantics('./my-project');\n  \n  // Generate questionnaire\n  const questionnaire = generateContextQuestionnaire(analysis);\n  \n  // Format as markdown\n  let markdown = `# ${questionnaire.title}\\n\\n${questionnaire.description}\\n\\n`;\n  \n  for (const q of questionnaire.questions) {\n    markdown += `## ${q.question}\\n\\n*${q.context}*\\n\\n`;\n    markdown += `Your answer: *(fill in here)*\\n\\n---\\n\\n`;\n  }\n  \n  // Save to file\n  fs.writeFileSync('questionnaire.md', markdown);\n  console.log('Questionnaire created: questionnaire.md');\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"visualization-functions",children:"Visualization Functions"}),"\n",(0,s.jsx)(n.p,{children:"Project Mapper also includes functions for visualizing project concepts and relationships:"}),"\n",(0,s.jsx)(n.h3,{id:"generateconceptnetworkvisualizationsemantics-options",children:"generateConceptNetworkVisualization(semantics, options)"}),"\n",(0,s.jsx)(n.p,{children:"Generates an SVG visualization of the concept network."}),"\n",(0,s.jsx)(n.h3,{id:"generatemermaidconceptdiagramsemantics-options",children:"generateMermaidConceptDiagram(semantics, options)"}),"\n",(0,s.jsx)(n.p,{children:"Generates a Mermaid.js diagram of the concept network."}),"\n",(0,s.jsx)(n.h3,{id:"exportinteractiveconceptnetworksemantics-outputpath",children:"exportInteractiveConceptNetwork(semantics, outputPath)"}),"\n",(0,s.jsx)(n.p,{children:"Creates an interactive HTML visualization of the concept network using D3.js."}),"\n",(0,s.jsx)(n.h3,{id:"generateconceptdistributionheatmapsemantics-options",children:"generateConceptDistributionHeatmap(semantics, options)"}),"\n",(0,s.jsx)(n.p,{children:"Generates an HTML table visualization showing concept distribution across files."}),"\n",(0,s.jsx)(n.h2,{id:"type-definitions",children:"Type Definitions"}),"\n",(0,s.jsx)(n.p,{children:"For TypeScript users, here are the main types used in the API:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface AnalysisOptions {\n  ignorePaths?: string[];\n  maxDepth?: number;\n  verbose?: boolean;\n}\n\ninterface KnowledgeTransferOptions {\n  projectName?: string;\n  template?: 'standard' | 'minimal' | 'detailed';\n  format?: 'markdown' | 'json';\n  includeGuide?: boolean;\n}\n\ninterface ProjectMapOptions extends AnalysisOptions, KnowledgeTransferOptions {\n  ignore?: string[];\n  depth?: number;\n}\n\ninterface SemanticAnalysisOptions {\n  ignorePaths?: string[];\n  includeComments?: boolean;\n  includeDocs?: boolean;\n  includeIdentifiers?: boolean;\n  minTermFrequency?: number;\n  maxTerms?: number;\n}\n\ninterface EnhancedKnowledgeTransferOptions extends KnowledgeTransferOptions {\n  projectDir?: string;\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);